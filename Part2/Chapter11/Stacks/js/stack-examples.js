// GLOBALS

// Set up the SVG view port
const dim = {
    height: 400,
    width: 1000,
    margin: {top: 50, right: 100, bottom: 50, left: 50}
};

const svg = d3.select("body")
    .append("svg")
    .attr("width", dim.width)
    .attr("height", dim.height);

// Set up the y-axis
// Use a scaleLinear() for the y-axis, so that the stackedData can be compared
const scaleY = d3.scaleLinear()
                 .range([dim.height - dim.margin.bottom, dim.margin.top]);
const colors = d3.scaleOrdinal(d3.schemeCategory10);
const axes = pkt.cartesianAxes();


/**
 * Shows axes and legend for the chart
 * @param container container where the axes will be rendered
 * @param keys An iterable of keys that represent the layers in the stack
 */
function showAxes(container, keys) {
    // Show axes
    axes.container(container)
        .yScale(scaleY)
        .xLabel('Observations')
        .yLabel('Values')
        .showHorizontalGrid(true)();

    // Add legend at right margin
    const legend = container.append("g")
        .attr("transform", `translate(${[dim.width/2 - dim.margin.right + 10, dim.height/2 - dim.margin.bottom]})`)
        .attr("class", "legend");

    pkt.legend()
        .container(legend)
        .data(keys)
        .color(colors)();
}

/**
 * Draws a simple stacked bar chart, for sample data
 * @param container The SVG container where the chart will be rendered
 * @param stackedData The data generated by a properly configured d3.stack() function
 * @param keys An iterable of keys that represent the layers in the stack
 * @param observations An array of observations, used to generate the x-axis
 */
function drawBarChart(container, stackedData, keys, observations = d3.range(stackedData[0].length)) {

    // Finish setting up the y-scale and color scale
    scaleY.domain([0, d3.max(d3.merge(d3.merge(stackedData)))]);
    colors.domain([0, stackedData.length-1]);

    // Use a band scale for the x-axis, so that the bars are spaced evenly
    const scaleX = d3.scaleBand()
        .range([dim.margin.left, dim.width/2 - dim.margin.right])
        .domain(observations)
        .padding(0.2);

    // Set the x-scale and render the Cartesian axes
    // Configure the Cartesian axes - this function is from the file chart-utils.js
    axes.xScale(scaleX);

    // render the stacked bars
    container.selectAll("g.layer")    // each group represents a layer
       .data(stackedData)
         .join("g").attr("class", "layer")
         .attr("fill", (d, i) => colors(i))   // assign a color to each layer
          .selectAll("rect")
            .data(d => d)        // each layer is an array of 2 values: [bottom, top] of a bar in the stack
              .join("rect")
                .attr("y", d => scaleY(d[1]))    // linear scale: top of bar is the top of the layer
                .attr("height", d => scaleY(d[0]) - scaleY(d[1])) // linear scale: height of bar is (bottom - top)
                .attr("x", (d,i) => scaleX(observations[i]))   // band scale: x position of the bar
                .attr("width", scaleX.bandwidth());          // band scale: width of the bar

    showAxes(container, keys);
}

/**
 * Draws a simple stacked area chart, for sample data
 * @param container The SVG container where the chart will be rendered
 * @param stackedData The data generated by a properly configured d3.stack() function
 * @param keys  An iterable of keys that represent the layers in the stack
 * @param observations An array of observations, used to generate the x-axis
 */
function drawAreaChart(container, stackedData, keys, observations = d3.range(stackedData[0].length)) {

    // Finish setting up the y-scale and color scale
    scaleY.domain([0, d3.max(d3.merge(d3.merge(stackedData)))]);
    colors.domain([0, stackedData.length-1]);

    // Use a band scale for the x-axis, so that the bars are spaced evenly
    const scaleX = d3.scalePoint()
                     .range([dim.margin.left, dim.width/2 - dim.margin.right])
                     .domain(observations);

    // Set the x-scale and render the Cartesian axes
    axes.xScale(scaleX);

    // Render the stacked area

    // The area function. The x-value can get the decade via d.data[0] or d.data.Decade
    const area = d3.area()
        .x((d,i) => scaleX(observations[i]))
        .y0(d => scaleY(d[0]))
        .y1(d => scaleY(d[1]));

    // Render the areas
    container.selectAll("path.area")
       .data(stackedData)
         .join("path")
           .attr("class", "area")
           .attr("d", d => area(d))
           .style("fill", (d,i) => colors(i));

    showAxes(container, keys);
}